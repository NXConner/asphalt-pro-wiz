#!/usr/bin/env tsx
/**
 * Render a sanitized `.env.runtime` file from the current environment.
 * - Reads `.env.example` to determine which keys should be exported.
 * - Loads `.env` (and optionally `.env.local`) so secrets stored locally are included.
 * - Produces an idempotent output suitable for Docker, Supabase CLI, or CI runners.
 *
 * Usage:
 *   npm run secrets:render -- [--output .env.runtime] [--source .env.production] [--strict]
 */

import { config as loadEnv } from 'dotenv';
import fs from 'node:fs/promises';
import path from 'node:path';
import process from 'node:process';

interface CliOptions {
  outputPath: string;
  sourcePath?: string;
  strict: boolean;
}

const projectRoot = path.resolve(__dirname, '..', '..');

function parseArgs(): CliOptions {
  const args = process.argv.slice(2);
  const getFlagValue = (flag: string): string | undefined => {
    const idx = args.indexOf(flag);
    return idx !== -1 ? args[idx + 1] : undefined;
  };

  return {
    outputPath: path.resolve(projectRoot, getFlagValue('--output') ?? '.env.runtime'),
    sourcePath: getFlagValue('--source'),
    strict: args.includes('--strict'),
  };
}

async function fileExists(targetPath: string): Promise<boolean> {
  try {
    await fs.access(targetPath);
    return true;
  } catch {
    return false;
  }
}

async function hydrateEnv(source?: string): Promise<void> {
  const candidates = source ? [source] : ['.env'];
  for (const relative of candidates) {
    const absolute = path.resolve(projectRoot, relative);
    if (await fileExists(absolute)) {
      loadEnv({ path: absolute, override: true });
    }
  }

  const localEnvPath = path.resolve(projectRoot, '.env.local');
  if (!source && (await fileExists(localEnvPath))) {
    loadEnv({ path: localEnvPath, override: true });
  }
}

async function loadRuntimeKeys(): Promise<string[]> {
  const examplePath = path.resolve(projectRoot, '.env.example');
  const content = await fs.readFile(examplePath, 'utf8');
  const keys = new Set<string>();
  const keyPattern = /^\s*([A-Z0-9_]+)=/;

  for (const rawLine of content.split(/\r?\n/)) {
    const trimmed = rawLine.trim();
    if (!trimmed || trimmed.startsWith('#') || trimmed.startsWith('##')) continue;
    const match = trimmed.match(keyPattern);
    if (match) {
      keys.add(match[1]);
    }
  }

  return Array.from(keys);
}

function escapeValue(value: string): string {
  return value.replace(/\r?\n/g, '\\n');
}

async function renderRuntimeFile(options: CliOptions): Promise<void> {
  await hydrateEnv(options.sourcePath);
  const runtimeKeys = await loadRuntimeKeys();
  const missing: string[] = [];
  const lines: string[] = [
    '# Auto-generated by scripts/secrets/render-runtime.ts',
    '# Safe to commit to runtime environments but never to version control.',
  ];

  for (const key of runtimeKeys) {
    const rawValue = process.env[key];
    if (rawValue === undefined || rawValue === '') {
      missing.push(key);
      continue;
    }
    lines.push(`${key}=${escapeValue(rawValue)}`);
  }

  if (missing.length > 0) {
    const message = `Missing ${missing.length} value(s): ${missing.join(', ')}`;
    if (options.strict) {
      throw new Error(`${message}. Re-run with --source <env file> or populate the variables before rendering.`);
    } else {
      console.warn(`[secrets:render] ${message} (these keys were skipped).`);
    }
  }

  await fs.writeFile(options.outputPath, `${lines.join('\n')}\n`, 'utf8');
  console.log(`[secrets:render] Wrote ${runtimeKeys.length - missing.length} keys to ${options.outputPath}`);
}

(async () => {
  try {
    const options = parseArgs();
    await renderRuntimeFile(options);
  } catch (error) {
    console.error('[secrets:render] Failed to render runtime env:', error instanceof Error ? error.message : error);
    process.exitCode = 1;
  }
})();
