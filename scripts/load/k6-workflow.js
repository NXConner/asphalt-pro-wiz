import http from 'k6/http';
import { check, sleep } from 'k6';

const REST_BASE = __ENV.WORKFLOW_SUPABASE_URL || 'http://localhost:54321/rest/v1';
const API_KEY = __ENV.WORKFLOW_SERVICE_ROLE_KEY || '';
const JOB_ID =
  __ENV.WORKFLOW_JOB_ID || '00000000-0000-0000-0000-000000000000';

if (!API_KEY) {
  throw new Error(
    'WORKFLOW_SERVICE_ROLE_KEY is required to exercise the workflow REST endpoints.',
  );
}

const HEADERS = {
  apikey: API_KEY,
  Authorization: `Bearer ${API_KEY}`,
  'Content-Type': 'application/json',
  Prefer: 'return=representation',
};

const STAGE_MULTIPLIER = Number(__ENV.STAGE_MULTIPLIER || 1);

export const options = {
  scenarios: {
    workflow: {
      executor: 'ramping-arrival-rate',
      startRate: 5 * STAGE_MULTIPLIER,
      timeUnit: '1m',
      preAllocatedVUs: 20 * STAGE_MULTIPLIER,
      maxVUs: 50 * STAGE_MULTIPLIER,
      stages: [
        { target: 20 * STAGE_MULTIPLIER, duration: '2m' },
        { target: 30 * STAGE_MULTIPLIER, duration: '3m' },
        { target: 0, duration: '1m' },
      ],
    },
  },
  thresholds: {
    http_req_duration: ['p(95)<800', 'p(99)<1500'],
    checks: ['rate>0.97'],
  },
};

function randomSquareFeet() {
  return Math.round(35000 + Math.random() * 15000);
}

function randomCrackFeet() {
  return Math.round(500 + Math.random() * 1200);
}

export default function workflowScenario() {
  const strategy = `k6-${__ITER % 5}`;
  const squareFeet = randomSquareFeet();
  const crackFeet = randomCrackFeet();

  const measurementPayload = {
    job_id: JOB_ID,
    strategy,
    status: 'completed',
    square_feet: squareFeet,
    crack_linear_feet: crackFeet,
    confidence: 0.8 + Math.random() * 0.15,
    notes: 'k6 workflow load test measurement',
    payload: { runner: 'k6', scenario: 'workflow' },
    result: {
      segments: [
        { label: 'North Lot', squareFeet: Math.round(squareFeet * 0.4) },
        { label: 'South Lot', squareFeet: Math.round(squareFeet * 0.35) },
        { label: 'Bus Loop', squareFeet: Math.round(squareFeet * 0.25) },
      ],
    },
  };

  const measurementRes = http.post(
    `${REST_BASE}/workflow_measurement_runs`,
    JSON.stringify(measurementPayload),
    { headers: HEADERS },
  );

  check(measurementRes, {
    'measurement run created': (res) => res.status === 201,
  });

  const measurementBody = measurementRes.json();
  const measurementId = Array.isArray(measurementBody) ? measurementBody[0]?.id : null;

  if (measurementId) {
    const segmentsPayload = measurementPayload.result.segments.map((segment) => ({
      measurement_id: measurementId,
      label: segment.label,
      square_feet: segment.squareFeet,
      metadata: { runner: 'k6' },
    }));

    const segmentRes = http.post(
      `${REST_BASE}/workflow_measurement_segments`,
      JSON.stringify(segmentsPayload),
      { headers: { ...HEADERS, Prefer: 'return=minimal' } },
    );

    check(segmentRes, {
      'segments inserted': (res) => res.status === 201 || res.status === 204,
    });
  }

  const stageEventPayload = {
    job_id: JOB_ID,
    stage_id: 'measure',
    status: 'done',
    notes: 'k6 workflow activity',
    payload: { runner: 'k6', scenario: 'workflow' },
  };

  const stageRes = http.post(
    `${REST_BASE}/workflow_stage_events`,
    JSON.stringify(stageEventPayload),
    { headers: { ...HEADERS, Prefer: 'return=minimal' } },
  );

  check(stageRes, {
    'stage event logged': (res) => res.status === 201 || res.status === 204,
  });

  const outreachPayload = {
    job_id: JOB_ID,
    channel: 'email',
    direction: 'outbound',
    status: 'sent',
    subject: 'Load-test outreach update',
    body: 'Synthetic outreach generated by k6.',
    contact: { name: 'Load Test Contact', email: 'loadtest@example.com' },
  };

  const outreachRes = http.post(
    `${REST_BASE}/workflow_outreach_touchpoints`,
    JSON.stringify(outreachPayload),
    { headers: { ...HEADERS, Prefer: 'return=minimal' } },
  );

  check(outreachRes, {
    'outreach recorded': (res) => res.status === 201 || res.status === 204,
  });

  const historyRes = http.get(
    `${REST_BASE}/workflow_measurement_runs?job_id=eq.${JOB_ID}&select=id,created_at,strategy,status`,
    { headers: HEADERS },
  );

  check(historyRes, {
    'history fetched': (res) => res.status === 200,
  });

  sleep(1);
}
